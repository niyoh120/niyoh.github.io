<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="niyoh" />
        <meta name="copyright" content="niyoh" />

<meta name="keywords" content=", golang, " />
        <title>[golang]学习笔记  · niyoh的博客
</title>
        <link href="http://cdn-images.mailchimp.com/embedcode/slim-081711.css" rel="stylesheet" type="text/css">
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="https://niyoh120.github.io/theme/css/style.css" media="screen">
        <link rel="stylesheet" type="text/css" href="https://niyoh120.github.io/theme/css/solarizedlight.css" media="screen">
        <link rel="shortcut icon" href="https://niyoh120.github.io/theme/images/favicon.ico" type="image/x-icon" />
        <link rel="apple-touch-icon" href="https://niyoh120.github.io/theme/images/apple-touch-icon.png" />
        <link rel="apple-touch-icon" sizes="57x57" href="https://niyoh120.github.io/theme/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="https://niyoh120.github.io/theme/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="https://niyoh120.github.io/theme/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="https://niyoh120.github.io/theme/images/apple-touch-icon-144x144.png" />
        <link rel="icon" href="https://niyoh120.github.io/theme/images/apple-touch-icon-144x144.png" />
        <link href="https://niyoh120.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="niyoh的博客 - Full Atom Feed" />
        <link href="https://niyoh120.github.io/feeds/alogrithm.atom.xml" type="application/atom+xml" rel="alternate" title="niyoh的博客 - alogrithm Category Atom Feed" />
        <link href="https://niyoh120.github.io/feeds/golang.atom.xml" type="application/atom+xml" rel="alternate" title="niyoh的博客 - golang Category Atom Feed" />
        <link href="https://niyoh120.github.io/feeds/test.atom.xml" type="application/atom+xml" rel="alternate" title="niyoh的博客 - test Category Atom Feed" />
    </head>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="https://niyoh120.github.io/"><span class=site-name>niyoh的博客</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="https://niyoh120.github.io">Home</a></li>
                            <li ><a href="https://niyoh120.github.io/categories.html">Categories</a></li>
                            <li ><a href="https://niyoh120.github.io/tags.html">Tags</a></li>
                            <li ><a href="https://niyoh120.github.io/archives.html">Archives</a></li>
                            <li><form class="navbar-search" action="https://niyoh120.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page_header span10 offset2">
    <h1><a href="https://niyoh120.github.io/golangxue-xi-bi-ji.html"> [golang]学习笔记  </a></h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">

            <h1>Golang 学习笔记</h1>
<h2>Type</h2>
<h3>Struct</h3>
<p>A field declared with a type but no explicit field name is called an embedded field. An embedded field must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type. The unqualified type name acts as the field name.</p>
<div class="highlight"><pre><span></span><span class="c1">// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4</span>
<span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">T1</span>        <span class="c1">// field name is T1</span>
    <span class="o">*</span><span class="nx">T2</span>       <span class="c1">// field name is T2</span>
    <span class="nx">P</span><span class="p">.</span><span class="nx">T3</span>      <span class="c1">// field name is T3</span>
    <span class="o">*</span><span class="nx">P</span><span class="p">.</span><span class="nx">T4</span>     <span class="c1">// field name is T4</span>
    <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span>  <span class="c1">// field names are x and y</span>
<span class="p">}</span>
</pre></div>


<p>A field or method f of an embedded field in a struct x is called promoted if x.f is a legal selector that denotes that field or method f.</p>
<p>Type embedded like class inherit.(嵌入类型的方法被提升,类似于OOP语言中的方法继承)</p>
<p>Promoted fields act like ordinary fields of a struct except that they cannot be used as field names in composite literals of the struct.</p>
<p>Given a struct type S and a type named T, promoted methods are included in the method set of the struct as follows:</p>
<ul>
<li>
<p>If S contains an embedded field T, the method sets of S and <em>S both include promoted methods with receiver T. The method set of </em>S also includes promoted methods with receiver *T.</p>
</li>
<li>
<p>If S contains an embedded field <em>T, the method sets of S and </em>S both include promoted methods with receiver T or *T.</p>
</li>
</ul>
<h3>Point</h3>
<p>go的类型可分为指针类型和非指针类型,go的指针更接近C++的引用,不像C,go没有指针运算</p>
<h3>Slice</h3>
<p>A slice does not store any data, it just describes a section of an underlying array.</p>
<p>Changing the elements of a slice modifies the corresponding elements of its underlying array.</p>
<p>Other slices that share the same underlying array will see those changes.</p>
<p>The zero value of a slice is nil.</p>
<p>A nil slice has a length and capacity of 0 and has no underlying array.</p>
<p>The range form of the for loop iterates over a slice or map.</p>
<p>When ranging over a slice, two values are returned for each iteration. The first is the index, and the second is a copy of the element at that index.</p>
<h3>Map</h3>
<p>Delete an element:</p>
<p><code>delete(m, key)</code></p>
<p>Test that a key is present with a two-value assignment:</p>
<p><code>elem, ok = m[key]</code></p>
<p>If key is in m, ok is true. If not, ok is false.</p>
<p>If key is not in the map, then elem is the zero value for the map's element type.</p>
<p>Note: if elem or ok have not yet been declared you could use a short declaration form:</p>
<p>elem, ok := m[key]</p>
<h3>Function</h3>
<p>Functions are values too. They can be passed around just like other values.</p>
<p>Function values may be used as function arguments and return values.</p>
<h3>Method</h3>
<p>You can only declare a method with a receiver whose type is defined in the same package as the method. You cannot declare a method with a receiver whose type is defined in another package (which includes the built-in types such as int).</p>
<p>methods with pointer receivers take either a value or a pointer as the receiver when they are called:</p>
<div class="highlight"><pre><span></span><span class="nx">v</span><span class="p">.</span><span class="nx">Scale</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1">// OK</span>
<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">v</span>
<span class="nx">p</span><span class="p">.</span><span class="nx">Scale</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// OK</span>
</pre></div>


<h3>Interface</h3>
<p>The interface type that specifies zero methods is known as the empty interface:</p>
<p><code>interface{}</code></p>
<p>An empty interface may hold values of any type. (Every type implements at least zero methods.)</p>
<p>Empty interfaces are used by code that handles values of unknown type. For example, fmt.Print takes any number of arguments of type interface{}.</p>
<h4>Type assertions</h4>
<p>A type assertion provides access to an interface value's underlying concrete value.</p>
<p><code>t := i.(T)</code></p>
<p>This statement asserts that the interface value i holds the concrete type T and assigns the underlying T value to the variable t.</p>
<p>If i does not hold a T, the statement will trigger a panic.</p>
<p>To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded.</p>
<p><code>t, ok := i.(T)</code></p>
<p>If i holds a T, then t will be the underlying value and ok will be true.</p>
<p>If not, ok will be false and t will be the zero value of type T, and no panic occurs.</p>
<h4>Type switches</h4>
<p>A type switch is a construct that permits several type assertions in series.</p>
<p>A type switch is like a regular switch statement, but the cases in a type switch specify types (not values), and those values are compared against the type of the value held by the given interface value.</p>
<div class="highlight"><pre><span></span><span class="k">switch</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="nx">T</span><span class="p">:</span>
    <span class="c1">// here v has type T</span>
<span class="k">case</span> <span class="nx">S</span><span class="p">:</span>
    <span class="c1">// here v has type S</span>
<span class="k">default</span><span class="p">:</span>
    <span class="c1">// no match; here v has the same type as i</span>
<span class="p">}</span>
</pre></div>


<p>The declaration in a type switch has the same syntax as a type assertion i.(T), but the specific type T is replaced with the keyword type.</p>
<p>This switch statement tests whether the interface value i holds a value of type T or S. In each of the T and S cases, the variable v will be of type T or S respectively and hold the value held by i. In the default case (where there is no match), the variable v is of the same interface type and value as i.</p>
<h3>Error</h3>
<p>Functions often return an error value, and calling code should handle errors by testing whether the error equals nil.</p>
<p>i, err := strconv.Atoi("42")
if err != nil {
    fmt.Printf("couldn't convert number: %v\n", err)
    return
}
fmt.Println("Converted integer:", i)
A nil error denotes success; a non-nil error denotes failure.</p>
<p>Note: a call to fmt.Sprint(e) inside the Error method will send the program into an infinite loop.</p>
<h3>Channel</h3>
<p>Channels are a typed conduit through which you can send and receive values with the channel operator, &lt;-.</p>
<div class="highlight"><pre><span></span><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">v</span>    <span class="c1">// Send v to channel ch.</span>
<span class="nx">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>  <span class="c1">// Receive from ch, and</span>
           <span class="c1">// assign value to v.</span>
</pre></div>


<p>(The data flows in the direction of the arrow.)</p>
<p>Like maps and slices, channels must be created before use:</p>
<p><code>ch := make(chan int)</code></p>
<p>By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.</p>
<p><code>fmt.Println(&lt;-ch)</code></p>
<p>A sender can close a channel to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression: after</p>
<p><code>v, ok := &lt;-ch</code></p>
<p>ok is false if there are no more values to receive and the channel is closed.</p>
<p>The <code>loop for i := range c</code> receives values from the channel repeatedly until it is closed.</p>
<p>Note: Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.</p>
<p>Another note: Channels aren't like files; you don't usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop.</p>
<p>When using channels as function parameters, you can specify if a channel is meant to only send or receive values. This specificity increases the type-safety of the program.</p>
<div class="highlight"><pre><span></span><span class="c1">// When using channels as function parameters, you can</span>
<span class="c1">// specify if a channel is meant to only send or receive</span>
<span class="c1">// values. This specificity increases the type-safety of</span>
<span class="c1">// the program.</span>

<span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&quot;fmt&quot;</span>

<span class="c1">// This `ping` function only accepts a channel for sending</span>
<span class="c1">// values. It would be a compile-time error to try to</span>
<span class="c1">// receive on this channel.</span>
<span class="kd">func</span> <span class="nx">ping</span><span class="p">(</span><span class="nx">pings</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">msg</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">pings</span> <span class="o">&lt;-</span> <span class="nx">msg</span>
<span class="p">}</span>

<span class="c1">// The `pong` function accepts one channel for receives</span>
<span class="c1">// (`pings`) and a second for sends (`pongs`).</span>
<span class="kd">func</span> <span class="nx">pong</span><span class="p">(</span><span class="nx">pings</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">pongs</span> <span class="kd">chan</span><span class="o">&lt;-</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">msg</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">pings</span>
    <span class="nx">pongs</span> <span class="o">&lt;-</span> <span class="nx">msg</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">pings</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">pongs</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">ping</span><span class="p">(</span><span class="nx">pings</span><span class="p">,</span> <span class="s">&quot;passed message&quot;</span><span class="p">)</span>
    <span class="nx">pong</span><span class="p">(</span><span class="nx">pings</span><span class="p">,</span> <span class="nx">pongs</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="o">&lt;-</span><span class="nx">pongs</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<h2>Control flow</h2>
<h3>Loop</h3>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span>
<span class="p">}</span>
</pre></div>


<p>the braces { } are always required.
If you omit the loop condition it loops forever.</p>
<h3>Condition</h3>
<p>if statement can start with a short statement to execute before the condition.</p>
<p>Variables declared by the statement are only in scope until the end of the if.</p>
<h3>Defer</h3>
<p>A defer statement defers the execution of a function until the surrounding function returns.</p>
<p>The deferred call's arguments are evaluated immediately, but the function call is not executed until the surrounding function returns</p>
<p>多个defer语句执行的顺序是其声明顺序的倒序</p>
<div class="highlight"><pre><span></span><span class="kd">func</span> <span class="nx">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;defer 1&quot;</span><span class="p">)</span>
    <span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;defer 2&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// output:</span>
<span class="c1">// defer 2</span>
<span class="c1">// defer 1</span>
</pre></div>


<h3>Select</h3>
<p>The select statement lets a goroutine wait on multiple communication operations.</p>
<p>A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.</p>
<p>Default Selection
The default case in a select is run if no other case is ready.</p>
<p>Use a default case to try a send or receive without blocking:</p>
<h2>Module</h2>
<p>function init is called before main.</p>
            <aside>
            <hr/>
            <nav>
            <ul class="articles_timeline">
 
                <li class="previous_article">« <a href="https://niyoh120.github.io/hello.html" title="Previous: hello">hello</a></li>
            </ul>
            </nav>
            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
 
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2018-03-25T22:00:11.646261+08:00">Mar 25, 2018</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#golang-ref">golang</a> 

        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    </body>
</html>