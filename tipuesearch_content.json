{"pages":[{"title":"理解Python的装饰器","text":"理解Python的装饰器 @decorator def foo (): pass 实际上等于 foo=decorator(foo) 装饰器的返回值应该是一个 callable ，这样 foo 才能被调用 In [ 11 ]: def decorator ( func ): ... : def wrap ( * args , ** kw ): ... : print ( 'in decorator' ) ... : return func ( * args , ** kw ) ... : return wrap ... : In [ 12 ]: @decorator ... : def foo (): ... : print ( 'in foo' ) ... : In [ 13 ]: foo () in decorator in foo foo=decorator(foo) 执行于 foo 的定义完成时（python中函数定义也是一种语句） 利用装饰器可以很方便的实现闭包，闭包可以理解为具有上下文的函数 def print_message ( msg ): def closeure ( func ): def wrap ( * args , ** kw ): print ( msg ) return func ( * args , ** kw ) return wrap return closeure @print_message ( 'msg1' ) def foo1 (): pass @print_message ( 'msg2' ) def foo2 (): pass foo1 () foo2 () >> msg1 >> msg2 装饰器可以嵌套，注意执行顺序是装饰器的使用顺序 def print_message ( msg ): def closeure ( func ): def wrap ( * args , ** kw ): print ( msg ) return func ( * args , ** kw ) return wrap return closeure @print_message ( 'msg1' ) @print_message ( 'msg2' ) def foo1 (): pass @print_message ( 'msg2' ) @print_message ( 'msg1' ) def foo2 (): pass foo1 () foo2 () >> msg1 >> msg2 >> msg2 >> msg1 因为装饰器实际上是语法糖，所以有一个问题，装饰器返回的函数并不是原本的函数，原本的函数的一些属性（如文档字符串）可能会丢失。 解决方法是使用 functools.wraps ，它会将原来函数的属性复制到装饰器返回的函数中。 >>> from functools import wraps >>> def my_decorator ( f ): ... @wraps ( f ) ... def wrapper ( * args , ** kwds ): ... print ( 'Calling decorated function' ) ... return f ( * args , ** kwds ) ... return wrapper ... >>> @my_decorator ... def example (): ... \"\"\"Docstring\"\"\" ... print ( 'Called example function' ) ... >>> example () Calling decorated function Called example function >>> example . __name__ 'example' >>> example . __doc__ 'Docstring'","tags":"python","url":"https://niyoh120.github.io/li-jie-pythonde-zhuang-shi-qi.html"},{"title":"理解Python的生成器","text":"理解Python的生成器 定义一个生成器的方法 定义一个含有 yield 语句的函数 定义一个实现了 __iter___ 方法（迭代器协议），方法中含有yield语句的类 通过内置的 next 函数和生成器的 send 方法，可以实现调用者与生成器之间的通信和控制流转移 In [ 1 ]: def gen (): ... : print ( 'in gen' ) ... : n = 0 ... : yield ... : while True : ... : print ( 'yield {}' . format ( n )) ... : n = yield n ... : print ( 'recv {}' . format ( n )) ... : return ... : In [ 2 ]: g = gen () In [ 3 ]: next ( g ) # 等于调用gen.send(None) in gen In [ 4 ]: g . send ( 1 ) yield 0 Out [ 5 ]: 0 In [ 6 ]: g . send ( 1 ) recv 1 yield 1 Out [ 7 ]: 1 首次调用 next 函数或生成器的 send 方法时，生成器会执行到第一个 yield 语句处然后返回，返回值为 yield 后跟的表达式的值，注意首次若是调用send方法，则传入的参数必须是 None ，否则会抛出异常 TypeError: can't send non-None value to a just-started generator 。 之后调用 send 方法时，其参数会作为生成器中 yield 语句的值传入，生成器会执行到下一个 yield 表达式处后再次返回。 生成器执行到 return 语句后会抛出 StopIteration 异常，返回值会赋值给异常的 value 属性。 内置的 for 语句和一些标准库设施在迭代生成器时会自动处理该异常，这会导致一些不易察觉的bug In [ 1 ]: def gen (): ... : for i in range ( 10 ): ... : yield i ... : return ... : In [ 2 ]: g = gen () In [ 3 ]: for i in g : ... : print ( i ) ... : 0 1 2 3 4 5 6 7 8 9 In [ 4 ]: for i in g : ... : print ( i ) ... : 第二次迭代不会有任何输出，因为生成器已经执行到了 return 语句，换句话说，生成器只能迭代一次。若需要多次迭代同一个生成器，应先将它转换成一个迭代器（最常见的方法是用 list 转换成一个列表然后迭代）","tags":"python","url":"https://niyoh120.github.io/li-jie-pythonde-sheng-cheng-qi.html"}]}