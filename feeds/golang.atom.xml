<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>niyoh的博客 - golang</title><link href="https://niyoh120.github.io/" rel="alternate"></link><link href="https://niyoh120.github.io/feeds/golang.atom.xml" rel="self"></link><id>https://niyoh120.github.io/</id><updated>2018-03-25T22:00:11+08:00</updated><entry><title>[golang]学习笔记</title><link href="https://niyoh120.github.io/golangxue-xi-bi-ji.html" rel="alternate"></link><published>2018-03-25T22:00:11+08:00</published><updated>2018-03-25T22:00:11+08:00</updated><author><name>niyoh</name></author><id>tag:niyoh120.github.io,2018-03-25:/golangxue-xi-bi-ji.html</id><summary type="html">&lt;h1&gt;Golang 学习笔记&lt;/h1&gt;
&lt;h2&gt;Type&lt;/h2&gt;
&lt;h3&gt;Struct&lt;/h3&gt;
&lt;p&gt;A field declared with a type but no explicit field name is called an embedded field. An embedded field must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;Golang 学习笔记&lt;/h1&gt;
&lt;h2&gt;Type&lt;/h2&gt;
&lt;h3&gt;Struct&lt;/h3&gt;
&lt;p&gt;A field declared with a type but no explicit field name is called an embedded field. An embedded field must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type. The unqualified type name acts as the field name.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4&lt;/span&gt;
&lt;span class="kd"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;T1&lt;/span&gt;        &lt;span class="c1"&gt;// field name is T1&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;T2&lt;/span&gt;       &lt;span class="c1"&gt;// field name is T2&lt;/span&gt;
    &lt;span class="nx"&gt;P&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;T3&lt;/span&gt;      &lt;span class="c1"&gt;// field name is T3&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;P&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;T4&lt;/span&gt;     &lt;span class="c1"&gt;// field name is T4&lt;/span&gt;
    &lt;span class="nx"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;y&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;  &lt;span class="c1"&gt;// field names are x and y&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A field or method f of an embedded field in a struct x is called promoted if x.f is a legal selector that denotes that field or method f.&lt;/p&gt;
&lt;p&gt;Type embedded like class inherit.(嵌入类型的方法被提升,类似于OOP语言中的方法继承)&lt;/p&gt;
&lt;p&gt;Promoted fields act like ordinary fields of a struct except that they cannot be used as field names in composite literals of the struct.&lt;/p&gt;
&lt;p&gt;Given a struct type S and a type named T, promoted methods are included in the method set of the struct as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;If S contains an embedded field T, the method sets of S and &lt;em&gt;S both include promoted methods with receiver T. The method set of &lt;/em&gt;S also includes promoted methods with receiver *T.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If S contains an embedded field &lt;em&gt;T, the method sets of S and &lt;/em&gt;S both include promoted methods with receiver T or *T.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Point&lt;/h3&gt;
&lt;p&gt;go的类型可分为指针类型和非指针类型,go的指针更接近C++的引用,不像C,go没有指针运算&lt;/p&gt;
&lt;h3&gt;Slice&lt;/h3&gt;
&lt;p&gt;A slice does not store any data, it just describes a section of an underlying array.&lt;/p&gt;
&lt;p&gt;Changing the elements of a slice modifies the corresponding elements of its underlying array.&lt;/p&gt;
&lt;p&gt;Other slices that share the same underlying array will see those changes.&lt;/p&gt;
&lt;p&gt;The zero value of a slice is nil.&lt;/p&gt;
&lt;p&gt;A nil slice has a length and capacity of 0 and has no underlying array.&lt;/p&gt;
&lt;p&gt;The range form of the for loop iterates over a slice or map.&lt;/p&gt;
&lt;p&gt;When ranging over a slice, two values are returned for each iteration. The first is the index, and the second is a copy of the element at that index.&lt;/p&gt;
&lt;h3&gt;Map&lt;/h3&gt;
&lt;p&gt;Delete an element:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;delete(m, key)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Test that a key is present with a two-value assignment:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;elem, ok = m[key]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If key is in m, ok is true. If not, ok is false.&lt;/p&gt;
&lt;p&gt;If key is not in the map, then elem is the zero value for the map's element type.&lt;/p&gt;
&lt;p&gt;Note: if elem or ok have not yet been declared you could use a short declaration form:&lt;/p&gt;
&lt;p&gt;elem, ok := m[key]&lt;/p&gt;
&lt;h3&gt;Function&lt;/h3&gt;
&lt;p&gt;Functions are values too. They can be passed around just like other values.&lt;/p&gt;
&lt;p&gt;Function values may be used as function arguments and return values.&lt;/p&gt;
&lt;h3&gt;Method&lt;/h3&gt;
&lt;p&gt;You can only declare a method with a receiver whose type is defined in the same package as the method. You cannot declare a method with a receiver whose type is defined in another package (which includes the built-in types such as int).&lt;/p&gt;
&lt;p&gt;methods with pointer receivers take either a value or a pointer as the receiver when they are called:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Scale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// OK&lt;/span&gt;
&lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;v&lt;/span&gt;
&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Scale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;// OK&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Interface&lt;/h3&gt;
&lt;p&gt;The interface type that specifies zero methods is known as the empty interface:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;interface{}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;An empty interface may hold values of any type. (Every type implements at least zero methods.)&lt;/p&gt;
&lt;p&gt;Empty interfaces are used by code that handles values of unknown type. For example, fmt.Print takes any number of arguments of type interface{}.&lt;/p&gt;
&lt;h4&gt;Type assertions&lt;/h4&gt;
&lt;p&gt;A type assertion provides access to an interface value's underlying concrete value.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;t := i.(T)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;This statement asserts that the interface value i holds the concrete type T and assigns the underlying T value to the variable t.&lt;/p&gt;
&lt;p&gt;If i does not hold a T, the statement will trigger a panic.&lt;/p&gt;
&lt;p&gt;To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;t, ok := i.(T)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;If i holds a T, then t will be the underlying value and ok will be true.&lt;/p&gt;
&lt;p&gt;If not, ok will be false and t will be the zero value of type T, and no panic occurs.&lt;/p&gt;
&lt;h4&gt;Type switches&lt;/h4&gt;
&lt;p&gt;A type switch is a construct that permits several type assertions in series.&lt;/p&gt;
&lt;p&gt;A type switch is like a regular switch statement, but the cases in a type switch specify types (not values), and those values are compared against the type of the value held by the given interface value.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;.(&lt;/span&gt;&lt;span class="kd"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// here v has type T&lt;/span&gt;
&lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nx"&gt;S&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// here v has type S&lt;/span&gt;
&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// no match; here v has the same type as i&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The declaration in a type switch has the same syntax as a type assertion i.(T), but the specific type T is replaced with the keyword type.&lt;/p&gt;
&lt;p&gt;This switch statement tests whether the interface value i holds a value of type T or S. In each of the T and S cases, the variable v will be of type T or S respectively and hold the value held by i. In the default case (where there is no match), the variable v is of the same interface type and value as i.&lt;/p&gt;
&lt;h3&gt;Error&lt;/h3&gt;
&lt;p&gt;Functions often return an error value, and calling code should handle errors by testing whether the error equals nil.&lt;/p&gt;
&lt;p&gt;i, err := strconv.Atoi("42")
if err != nil {
    fmt.Printf("couldn't convert number: %v\n", err)
    return
}
fmt.Println("Converted integer:", i)
A nil error denotes success; a non-nil error denotes failure.&lt;/p&gt;
&lt;p&gt;Note: a call to fmt.Sprint(e) inside the Error method will send the program into an infinite loop.&lt;/p&gt;
&lt;h3&gt;Channel&lt;/h3&gt;
&lt;p&gt;Channels are a typed conduit through which you can send and receive values with the channel operator, &amp;lt;-.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;v&lt;/span&gt;    &lt;span class="c1"&gt;// Send v to channel ch.&lt;/span&gt;
&lt;span class="nx"&gt;v&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt;  &lt;span class="c1"&gt;// Receive from ch, and&lt;/span&gt;
           &lt;span class="c1"&gt;// assign value to v.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;(The data flows in the direction of the arrow.)&lt;/p&gt;
&lt;p&gt;Like maps and slices, channels must be created before use:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ch := make(chan int)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;By default, sends and receives block until the other side is ready. This allows goroutines to synchronize without explicit locks or condition variables.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fmt.Println(&amp;lt;-ch)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;A sender can close a channel to indicate that no more values will be sent. Receivers can test whether a channel has been closed by assigning a second parameter to the receive expression: after&lt;/p&gt;
&lt;p&gt;&lt;code&gt;v, ok := &amp;lt;-ch&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ok is false if there are no more values to receive and the channel is closed.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;loop for i := range c&lt;/code&gt; receives values from the channel repeatedly until it is closed.&lt;/p&gt;
&lt;p&gt;Note: Only the sender should close a channel, never the receiver. Sending on a closed channel will cause a panic.&lt;/p&gt;
&lt;p&gt;Another note: Channels aren't like files; you don't usually need to close them. Closing is only necessary when the receiver must be told there are no more values coming, such as to terminate a range loop.&lt;/p&gt;
&lt;p&gt;When using channels as function parameters, you can specify if a channel is meant to only send or receive values. This specificity increases the type-safety of the program.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// When using channels as function parameters, you can&lt;/span&gt;
&lt;span class="c1"&gt;// specify if a channel is meant to only send or receive&lt;/span&gt;
&lt;span class="c1"&gt;// values. This specificity increases the type-safety of&lt;/span&gt;
&lt;span class="c1"&gt;// the program.&lt;/span&gt;

&lt;span class="kn"&gt;package&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;fmt&amp;quot;&lt;/span&gt;

&lt;span class="c1"&gt;// This `ping` function only accepts a channel for sending&lt;/span&gt;
&lt;span class="c1"&gt;// values. It would be a compile-time error to try to&lt;/span&gt;
&lt;span class="c1"&gt;// receive on this channel.&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;ping&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;pings&lt;/span&gt; &lt;span class="kd"&gt;chan&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;msg&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;pings&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;msg&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// The `pong` function accepts one channel for receives&lt;/span&gt;
&lt;span class="c1"&gt;// (`pings`) and a second for sends (`pongs`).&lt;/span&gt;
&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;pong&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;pings&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;pongs&lt;/span&gt; &lt;span class="kd"&gt;chan&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;pings&lt;/span&gt;
    &lt;span class="nx"&gt;pongs&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;msg&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;pings&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;pongs&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="nb"&gt;make&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;chan&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;ping&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;pings&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;passed message&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;pong&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;pings&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;pongs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;&lt;span class="nx"&gt;pongs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Control flow&lt;/h2&gt;
&lt;h3&gt;Loop&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;the braces { } are always required.
If you omit the loop condition it loops forever.&lt;/p&gt;
&lt;h3&gt;Condition&lt;/h3&gt;
&lt;p&gt;if statement can start with a short statement to execute before the condition.&lt;/p&gt;
&lt;p&gt;Variables declared by the statement are only in scope until the end of the if.&lt;/p&gt;
&lt;h3&gt;Defer&lt;/h3&gt;
&lt;p&gt;A defer statement defers the execution of a function until the surrounding function returns.&lt;/p&gt;
&lt;p&gt;The deferred call's arguments are evaluated immediately, but the function call is not executed until the surrounding function returns&lt;/p&gt;
&lt;p&gt;多个defer语句执行的顺序是其声明顺序的倒序&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;defer 1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="nx"&gt;fmt&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;Println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;defer 2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// output:&lt;/span&gt;
&lt;span class="c1"&gt;// defer 2&lt;/span&gt;
&lt;span class="c1"&gt;// defer 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Select&lt;/h3&gt;
&lt;p&gt;The select statement lets a goroutine wait on multiple communication operations.&lt;/p&gt;
&lt;p&gt;A select blocks until one of its cases can run, then it executes that case. It chooses one at random if multiple are ready.&lt;/p&gt;
&lt;p&gt;Default Selection
The default case in a select is run if no other case is ready.&lt;/p&gt;
&lt;p&gt;Use a default case to try a send or receive without blocking:&lt;/p&gt;
&lt;h2&gt;Module&lt;/h2&gt;
&lt;p&gt;function init is called before main.&lt;/p&gt;</content></entry><entry><title>[golang]net库使用笔记</title><link href="https://niyoh120.github.io/golangnetku-shi-yong-bi-ji.html" rel="alternate"></link><published>2018-03-11T13:50:26+08:00</published><updated>2018-03-11T13:50:26+08:00</updated><author><name>niyoh</name></author><id>tag:niyoh120.github.io,2018-03-11:/golangnetku-shi-yong-bi-ji.html</id><summary type="html">&lt;h1&gt;net库使用笔记&lt;/h1&gt;
&lt;p&gt;Conn类型的方法是线程安全的,即可以在多个goroutine中同时调用而无需加锁&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ParseIp&lt;/code&gt;方法返回的是16字节的byte数组,ipv4地址会被转换成对应的ipv6形式&lt;/p&gt;
&lt;p&gt;setDe&lt;/p&gt;</summary><content type="html">&lt;h1&gt;net库使用笔记&lt;/h1&gt;
&lt;p&gt;Conn类型的方法是线程安全的,即可以在多个goroutine中同时调用而无需加锁&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ParseIp&lt;/code&gt;方法返回的是16字节的byte数组,ipv4地址会被转换成对应的ipv6形式&lt;/p&gt;
&lt;p&gt;setDe&lt;/p&gt;</content></entry><entry><title>[golang]如何正确关闭一个channel</title><link href="https://niyoh120.github.io/golangru-he-zheng-que-guan-bi-yi-ge-channel.html" rel="alternate"></link><published>2018-03-11T13:50:26+08:00</published><updated>2018-03-11T13:50:26+08:00</updated><author><name>niyoh</name></author><id>tag:niyoh120.github.io,2018-03-11:/golangru-he-zheng-que-guan-bi-yi-ge-channel.html</id><summary type="html">&lt;h1&gt;如何优雅地关闭channel&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;close一个channel的原则&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;永远只在发送端close一个channel，也就是不要在接收端close一个channel&lt;/li&gt;
&lt;li&gt;不要直接close一个有多个发送者的channel，除非能确定负责关闭的是最后一个还在活动的发送者&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果需要处理上面的情况，可以考虑使用&lt;code&gt;sync.once&lt;/code&gt;或者&lt;code&gt;sync.mutex&lt;/code&gt;设置一个指示channel已关闭的变量，或者添加一个&lt;code&gt;safeSend&lt;/code&gt; 函数，代码如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;safeSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="kd"&gt;chan&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;closed&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// 如果channel已经close，发送会导致panic，内置函数recover不会返回nil&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;recover&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;closed&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt;
    &lt;span class="nx"&gt;closed&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种方式的缺点是不能使用内置的&lt;code&gt;select&lt;/code&gt;的语句&lt;/p&gt;
&lt;p&gt;有两种更优雅的解决方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要从1个接收端关闭channel的情况&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;设置1个用来发送信号的channel，用来通知所有发送端不要再发送数据给channel了&lt;/p&gt;
&lt;p&gt;```go …&lt;/p&gt;</summary><content type="html">&lt;h1&gt;如何优雅地关闭channel&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;close一个channel的原则&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;永远只在发送端close一个channel，也就是不要在接收端close一个channel&lt;/li&gt;
&lt;li&gt;不要直接close一个有多个发送者的channel，除非能确定负责关闭的是最后一个还在活动的发送者&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果需要处理上面的情况，可以考虑使用&lt;code&gt;sync.once&lt;/code&gt;或者&lt;code&gt;sync.mutex&lt;/code&gt;设置一个指示channel已关闭的变量，或者添加一个&lt;code&gt;safeSend&lt;/code&gt; 函数，代码如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;func&lt;/span&gt; &lt;span class="nx"&gt;safeSend&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="kd"&gt;chan&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;closed&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;defer&lt;/span&gt; &lt;span class="kd"&gt;func&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// 如果channel已经close，发送会导致panic，内置函数recover不会返回nil&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;recover&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;nil&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;closed&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
    &lt;span class="nx"&gt;ch&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="nx"&gt;value&lt;/span&gt;
    &lt;span class="nx"&gt;closed&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种方式的缺点是不能使用内置的&lt;code&gt;select&lt;/code&gt;的语句&lt;/p&gt;
&lt;p&gt;有两种更优雅的解决方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要从1个接收端关闭channel的情况&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;设置1个用来发送信号的channel，用来通知所有发送端不要再发送数据给channel了&lt;/p&gt;
&lt;p&gt;```go
   package main&lt;/p&gt;
&lt;p&gt;import (
    "log"
    "math/rand"
    "sync"
    "time"
   )&lt;/p&gt;
&lt;p&gt;func main() {
    const maxRandomNum = 10000
    const sendersNum = 100
    done := make(chan struct{})
    dataCh := make(chan int, 100)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;log.SetFlags&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
rand.Seed&lt;span class="p"&gt;(&lt;/span&gt;time.Now&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="m"&gt;.&lt;/span&gt;UnixNano&lt;span class="p"&gt;())&lt;/span&gt;

wgSenders &lt;span class="o"&gt;:=&lt;/span&gt; sync.WaitGroup&lt;span class="p"&gt;{}&lt;/span&gt;

&lt;span class="kr"&gt;for&lt;/span&gt; i &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; i &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; sendersNum&lt;span class="p"&gt;;&lt;/span&gt; i&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    wgSenders.Add&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    go func&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        defer wgSenders.Done&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="kr"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            select &lt;span class="p"&gt;{&lt;/span&gt;
            case &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;done&lt;span class="o"&gt;:&lt;/span&gt;
                &lt;span class="kr"&gt;return&lt;/span&gt;
            case dataCh &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; rand.Intn&lt;span class="p"&gt;(&lt;/span&gt;maxRandomNum&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;for&lt;/span&gt; v &lt;span class="o"&gt;:=&lt;/span&gt; range dataCh &lt;span class="p"&gt;{&lt;/span&gt;
    log.Println&lt;span class="p"&gt;(&lt;/span&gt;v&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kr"&gt;if&lt;/span&gt; v &lt;span class="o"&gt;==&lt;/span&gt; maxRandomNum&lt;span class="m"&gt;-1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kp"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;done&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="kr"&gt;break&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
wgSenders.Wait&lt;span class="p"&gt;()&lt;/span&gt;
log.Println&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;done&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kp"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;dataCh&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}
   ```&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要从多个接收端或发送端关闭channel的情况
  设置一个仲裁者，当需要关闭channel时，通知仲裁者关闭channel&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;```go
  package main&lt;/p&gt;
&lt;p&gt;import (
    "log"
    "math/rand"
    "sync"
    "time"
  )&lt;/p&gt;
&lt;p&gt;func main() {
    const maxRandomNum = 10000
    const sendersNum = 100
    const receiversNum = 10
    done := make(chan struct{})
    toDone := make(chan struct{})
    dataCh := make(chan int, 100)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;log.SetFlags&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
rand.Seed&lt;span class="p"&gt;(&lt;/span&gt;time.Now&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="m"&gt;.&lt;/span&gt;UnixNano&lt;span class="p"&gt;())&lt;/span&gt;

wgSenders &lt;span class="o"&gt;:=&lt;/span&gt; sync.WaitGroup&lt;span class="p"&gt;{}&lt;/span&gt;
wgReceivers &lt;span class="o"&gt;:=&lt;/span&gt; sync.WaitGroup&lt;span class="p"&gt;{}&lt;/span&gt;

&lt;span class="kr"&gt;for&lt;/span&gt; i &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; i &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; sendersNum&lt;span class="p"&gt;;&lt;/span&gt; i&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    wgSenders.Add&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    go func&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        defer wgSenders.Done&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="kr"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            v &lt;span class="o"&gt;:=&lt;/span&gt; rand.Intn&lt;span class="p"&gt;(&lt;/span&gt;maxRandomNum&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="kr"&gt;if&lt;/span&gt; v &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                select &lt;span class="p"&gt;{&lt;/span&gt;
                case toDone &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; struct&lt;span class="p"&gt;{}{}&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
                default&lt;span class="o"&gt;:&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="kr"&gt;return&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            select &lt;span class="p"&gt;{&lt;/span&gt;
            case &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;done&lt;span class="o"&gt;:&lt;/span&gt;
                &lt;span class="kr"&gt;return&lt;/span&gt;
            case dataCh &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; v&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;for&lt;/span&gt; i &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; i &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; receiversNum&lt;span class="p"&gt;;&lt;/span&gt; i&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    wgReceivers.Add&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    go func&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        defer wgReceivers.Done&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="kr"&gt;for&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            select &lt;span class="p"&gt;{&lt;/span&gt;
            case &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;done&lt;span class="o"&gt;:&lt;/span&gt;
                &lt;span class="kr"&gt;return&lt;/span&gt;
            case v &lt;span class="o"&gt;:=&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;dataCh&lt;span class="o"&gt;:&lt;/span&gt;
                log.Println&lt;span class="p"&gt;(&lt;/span&gt;v&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="kr"&gt;if&lt;/span&gt; v &lt;span class="o"&gt;==&lt;/span&gt; maxRandomNum&lt;span class="m"&gt;-1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    select &lt;span class="p"&gt;{&lt;/span&gt;
                    case toDone &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; struct&lt;span class="p"&gt;{}{}&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
                    default&lt;span class="o"&gt;:&lt;/span&gt;
                    &lt;span class="p"&gt;}&lt;/span&gt;
                    &lt;span class="kr"&gt;return&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;&amp;lt;-&lt;/span&gt;toDone
&lt;span class="kp"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;done&lt;span class="p"&gt;)&lt;/span&gt;
wgSenders.Wait&lt;span class="p"&gt;()&lt;/span&gt;
wgReceivers.Wait&lt;span class="p"&gt;()&lt;/span&gt;
log.Println&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;done&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="kp"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;dataCh&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;}
  ```&lt;/p&gt;
&lt;h3&gt;参考&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;http://www.tapirgames.com/blog/golang-channel-closing&lt;/li&gt;
&lt;/ul&gt;</content></entry></feed>